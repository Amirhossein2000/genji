{
    package parser
}

Input <- _ stmt:Statement _ EOF {
    return stmt, nil
}

Statement <- _ selectStmt:SelectStmt {
    return selectStmt, nil
}

/*
Common rules
*/

Integer ← '0' / NonZeroDecimalDigit DecimalDigit*

DecimalDigit ← [0-9]

NonZeroDecimalDigit ← [1-9]

Exponent ← 'e'i [+-]? DecimalDigit+

Word <- (EnglishChar / UnicodeChar)+ (EnglishChar / UnicodeChar / '_')* {
    return string(c.text), nil
}

SingleQuotedWord <- "'" v:Word "'" {
    return v, nil
}

DoubleQuotedWord <- '"' v:Word '"' {
    return v, nil
}

EnglishChar <- [a-zA-Z]

UnicodeChar <- [^\u0000-\u007F]

_ "whitespace" <- [ \n\t\r]*

EOF <- !.

/*
Expression
*/

Expr <- Scalar / FieldSelector 

/*
Expression - Scalar
*/

Scalar <- StringScalar / NumericScalar / BoolScalar

StringScalar <- val:(SingleQuotedWord / DoubleQuotedWord) {
    return &query.Scalar{Type: field.String, Data: []byte(val.(string))}, nil
}

NumericScalar ← '-'? Integer fractional:( '.' DecimalDigit+ )? Exponent? {
    if fractional != nil {
        f, err := strconv.ParseFloat(string(c.text), 64)
        if err != nil {
            return nil, err
        }

        return &query.Scalar{Type: field.Float64, Data: field.EncodeFloat64(f)}, nil
    }

    i, err := strconv.ParseInt(string(c.text), 10, 64)
    if err != nil {
        return nil, err
    }

    return &query.Scalar{Type: field.Int64, Data: field.EncodeInt64(i)}, nil
}

BoolScalar <- v:("true" / "TRUE" / "false" / "FALSE" ) {
    x, err := strconv.ParseBool(string(c.text))
    if err != nil {
        return nil, err
    }
    return &query.Scalar{Type: field.Bool, Data: field.EncodeBool(x)}, nil
}

/*
Expression - Field Selector
*/

FieldSelector <- Word {
    return query.Field(c.text), nil
}

/*
Expression - Operators
*/

Operator <- BinaryOperator

BinaryOperator <- Expr _ (EqOperator) _ Expr

EqOperator <- "eq" {
    return query.Eq
}

/*
Select Statement
*/

SelectStmt "Select statement" <- SelectKeyWord _ from:From _ where:Where? {
    q := query.Select().From(from.(query.Table))
    if where != nil {
        q = q.Where(where.(query.Expr))
    }
    return q, nil
}

SelectKeyWord <- "select"i

From <- FromKeyWord _ tableName:TableName {
    return query.Table(tableName.(string)), nil
}

FromKeyWord <- "from"i

TableName <- tableName:Word {
    return tableName, nil
}

// Where clause
Where <- WhereKeyWord _ expr:Expr {
    return expr, nil
}

WhereKeyWord <- "where"i

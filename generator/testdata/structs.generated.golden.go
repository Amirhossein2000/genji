// Code generated by genji.
// DO NOT EDIT!

package testdata

import (
	"errors"

	"github.com/asdine/genji"
	"github.com/asdine/genji/field"
	"github.com/asdine/genji/query"
	"github.com/asdine/genji/record"
	"github.com/asdine/genji/table"
)

// Field implements the field method of the record.Record interface.
func (b *Basic) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", b.A), nil
	case "B":
		return field.NewInt("B", b.B), nil
	case "C":
		return field.NewInt32("C", b.C), nil
	case "D":
		return field.NewInt32("D", b.D), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (b *Basic) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = b.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("C")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("D")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (b *Basic) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			b.A, err = field.DecodeString(f.Data)
		case "B":
			b.B, err = field.DecodeInt(f.Data)
		case "C":
			b.C, err = field.DecodeInt32(f.Data)
		case "D":
			b.D, err = field.DecodeInt32(f.Data)
		}
		return err
	})
}

// BasicTableSchema provides provides information about the Basic table.
type BasicTableSchema struct {
	A query.StringFieldSelector
	B query.IntFieldSelector
	C query.Int32FieldSelector
	D query.Int32FieldSelector
}

// NewBasicTableSchema creates a BasicTableSchema.
func NewBasicTableSchema() BasicTableSchema {
	return BasicTableSchema{
		A: query.StringField("A"),
		B: query.IntField("B"),
		C: query.Int32Field("C"),
		D: query.Int32Field("D"),
	}
}

// Init initializes the Basic table by ensuring the table and its index are created.
func (s *BasicTableSchema) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, s)
}

// Table returns a query.TableSelector for Basic.
func (*BasicTableSchema) Table() query.TableSelector {
	return query.Table("Basic")
}

// TableName returns the name of the table.
func (s *BasicTableSchema) TableName() string {
	return "Basic"
}

// All returns a list of all selectors for Basic.
func (s *BasicTableSchema) All() []query.FieldSelector {
	return []query.FieldSelector{
		s.A,
		s.B,
		s.C,
		s.D,
	}
}

// BasicResult can be used to store the result of queries.
// Selected fields must map the Basic fields.
type BasicResult []Basic

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (b *BasicResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Basic
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*b = append(*b, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (b *basic) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewBytes("A", b.A), nil
	case "B":
		return field.NewUint16("B", b.B), nil
	case "C":
		return field.NewFloat32("C", b.C), nil
	case "D":
		return field.NewFloat32("D", b.D), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (b *basic) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = b.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("C")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("D")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (b *basic) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			b.A, err = field.DecodeBytes(f.Data)
		case "B":
			b.B, err = field.DecodeUint16(f.Data)
		case "C":
			b.C, err = field.DecodeFloat32(f.Data)
		case "D":
			b.D, err = field.DecodeFloat32(f.Data)
		}
		return err
	})
}

// basicTableSchema provides provides information about the Basic table.
type basicTableSchema struct {
	A query.BytesFieldSelector
	B query.Uint16FieldSelector
	C query.Float32FieldSelector
	D query.Float32FieldSelector
}

// newbasicTableSchema creates a basicTableSchema.
func newBasicTableSchema() basicTableSchema {
	return basicTableSchema{
		A: query.BytesField("A"),
		B: query.Uint16Field("B"),
		C: query.Float32Field("C"),
		D: query.Float32Field("D"),
	}
}

// Init initializes the Basic table by ensuring the table and its index are created.
func (s *basicTableSchema) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, s)
}

// Table returns a query.TableSelector for basic.
func (*basicTableSchema) Table() query.TableSelector {
	return query.Table("Basic")
}

// TableName returns the name of the table.
func (s *basicTableSchema) TableName() string {
	return "Basic"
}

// All returns a list of all selectors for basic.
func (s *basicTableSchema) All() []query.FieldSelector {
	return []query.FieldSelector{
		s.A,
		s.B,
		s.C,
		s.D,
	}
}

// basicResult can be used to store the result of queries.
// Selected fields must map the basic fields.
type basicResult []basic

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (b *basicResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record basic
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*b = append(*b, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (p *Pk) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", p.A), nil
	case "B":
		return field.NewInt64("B", p.B), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (p *Pk) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = p.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = p.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (p *Pk) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			p.A, err = field.DecodeString(f.Data)
		case "B":
			p.B, err = field.DecodeInt64(f.Data)
		}
		return err
	})
}

// Pk returns the primary key. It implements the table.Pker interface.
func (p *Pk) Pk() ([]byte, error) {
	return field.EncodeInt64(p.B), nil
}

// PkTableSchema provides provides information about the Pk table.
type PkTableSchema struct {
	A query.StringFieldSelector
	B query.Int64FieldSelector
}

// NewPkTableSchema creates a PkTableSchema.
func NewPkTableSchema() PkTableSchema {
	return PkTableSchema{
		A: query.StringField("A"),
		B: query.Int64Field("B"),
	}
}

// Init initializes the Pk table by ensuring the table and its index are created.
func (s *PkTableSchema) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, s)
}

// Table returns a query.TableSelector for Pk.
func (*PkTableSchema) Table() query.TableSelector {
	return query.Table("Pk")
}

// TableName returns the name of the table.
func (s *PkTableSchema) TableName() string {
	return "Pk"
}

// All returns a list of all selectors for Pk.
func (s *PkTableSchema) All() []query.FieldSelector {
	return []query.FieldSelector{
		s.A,
		s.B,
	}
}

// PkResult can be used to store the result of queries.
// Selected fields must map the Pk fields.
type PkResult []Pk

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (p *PkResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Pk
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*p = append(*p, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (i *Indexed) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", i.A), nil
	case "B":
		return field.NewInt64("B", i.B), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (i *Indexed) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = i.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = i.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (i *Indexed) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			i.A, err = field.DecodeString(f.Data)
		case "B":
			i.B, err = field.DecodeInt64(f.Data)
		}
		return err
	})
}

// IndexedTableSchema provides provides information about the Indexed table.
type IndexedTableSchema struct {
	A query.StringFieldSelector
	B query.Int64FieldSelector
}

// NewIndexedTableSchema creates a IndexedTableSchema.
func NewIndexedTableSchema() IndexedTableSchema {
	return IndexedTableSchema{
		A: query.StringField("A"),
		B: query.Int64Field("B"),
	}
}

// Init initializes the Indexed table by ensuring the table and its index are created.
func (s *IndexedTableSchema) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, s)
}

// Table returns a query.TableSelector for Indexed.
func (*IndexedTableSchema) Table() query.TableSelector {
	return query.Table("Indexed")
}

// TableName returns the name of the table.
func (s *IndexedTableSchema) TableName() string {
	return "Indexed"
}

// All returns a list of all selectors for Indexed.
func (s *IndexedTableSchema) All() []query.FieldSelector {
	return []query.FieldSelector{
		s.A,
		s.B,
	}
}

// IndexedResult can be used to store the result of queries.
// Selected fields must map the Indexed fields.
type IndexedResult []Indexed

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (i *IndexedResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Indexed
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*i = append(*i, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (m *MultipleTags) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", m.A), nil
	case "B":
		return field.NewInt64("B", m.B), nil
	case "C":
		return field.NewFloat32("C", m.C), nil
	case "D":
		return field.NewBool("D", m.D), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (m *MultipleTags) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = m.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = m.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = m.Field("C")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = m.Field("D")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (m *MultipleTags) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			m.A, err = field.DecodeString(f.Data)
		case "B":
			m.B, err = field.DecodeInt64(f.Data)
		case "C":
			m.C, err = field.DecodeFloat32(f.Data)
		case "D":
			m.D, err = field.DecodeBool(f.Data)
		}
		return err
	})
}

// Pk returns the primary key. It implements the table.Pker interface.
func (m *MultipleTags) Pk() ([]byte, error) {
	return field.EncodeString(m.A), nil
}

// MultipleTagsTableSchema provides provides information about the MultipleTags table.
type MultipleTagsTableSchema struct {
	A query.StringFieldSelector
	B query.Int64FieldSelector
	C query.Float32FieldSelector
	D query.BoolFieldSelector
}

// NewMultipleTagsTableSchema creates a MultipleTagsTableSchema.
func NewMultipleTagsTableSchema() MultipleTagsTableSchema {
	return MultipleTagsTableSchema{
		A: query.StringField("A"),
		B: query.Int64Field("B"),
		C: query.Float32Field("C"),
		D: query.BoolField("D"),
	}
}

// Init initializes the MultipleTags table by ensuring the table and its index are created.
func (s *MultipleTagsTableSchema) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, s)
}

// Table returns a query.TableSelector for MultipleTags.
func (*MultipleTagsTableSchema) Table() query.TableSelector {
	return query.Table("MultipleTags")
}

// TableName returns the name of the table.
func (s *MultipleTagsTableSchema) TableName() string {
	return "MultipleTags"
}

// All returns a list of all selectors for MultipleTags.
func (s *MultipleTagsTableSchema) All() []query.FieldSelector {
	return []query.FieldSelector{
		s.A,
		s.B,
		s.C,
		s.D,
	}
}

// MultipleTagsResult can be used to store the result of queries.
// Selected fields must map the MultipleTags fields.
type MultipleTagsResult []MultipleTags

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (m *MultipleTagsResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record MultipleTags
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*m = append(*m, record)
		return nil
	})
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (s *Sample) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			s.A, err = field.DecodeString(f.Data)
		case "B":
			s.B, err = field.DecodeInt64(f.Data)
		}
		return err
	})
}

// SampleResult can be used to store the result of queries.
// Selected fields must map the Sample fields.
type SampleResult []Sample

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (s *SampleResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Sample
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*s = append(*s, record)
		return nil
	})
}

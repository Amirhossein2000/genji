// Code generated by genji.
// DO NOT EDIT!

package testdata

import (
	"errors"

	"github.com/asdine/genji"
	"github.com/asdine/genji/field"
	"github.com/asdine/genji/query"
	"github.com/asdine/genji/record"
	"github.com/asdine/genji/table"
)

// Field implements the field method of the record.Record interface.
func (b *Basic) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", b.A), nil
	case "B":
		return field.NewInt("B", b.B), nil
	case "C":
		return field.NewInt32("C", b.C), nil
	case "D":
		return field.NewInt32("D", b.D), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (b *Basic) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = b.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("C")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("D")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (b *Basic) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			b.A, err = field.DecodeString(f.Data)
		case "B":
			b.B, err = field.DecodeInt(f.Data)
		case "C":
			b.C, err = field.DecodeInt32(f.Data)
		case "D":
			b.D, err = field.DecodeInt32(f.Data)
		}
		return err
	})
}

// BasicTable manages the Basic table.
type BasicTable struct {
	A query.StringFieldSelector
	B query.IntFieldSelector
	C query.Int32FieldSelector
	D query.Int32FieldSelector
}

// NewBasicTable creates a BasicTable.
func NewBasicTable() *BasicTable {
	return &BasicTable{
		A: query.StringField("A"),
		B: query.IntField("B"),
		C: query.Int32Field("C"),
		D: query.Int32Field("D"),
	}
}

// Init initializes the Basic table by ensuring the table and its index are created.
func (t *BasicTable) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, t)
}

// SelectTable implements the query.TableSelector interface. It gets the Basic table from
// the transaction.
func (t *BasicTable) SelectTable(tx *genji.Tx) (*genji.Table, error) {
	return tx.Table(t.TableName())
}

// Insert is a shortcut that gets the Basic table from the transaction and
// inserts a Basic into it.
func (t *BasicTable) Insert(tx *genji.Tx, x *Basic) ([]byte, error) {
	tb, err := t.SelectTable(tx)
	if err != nil {
		return nil, err
	}

	return tb.Insert(x)
}

// TableName returns the name of the table.
func (*BasicTable) TableName() string {
	return "Basic"
}

// All returns a list of all selectors for Basic.
func (t *BasicTable) All() []query.FieldSelector {
	return []query.FieldSelector{
		t.A,
		t.B,
		t.C,
		t.D,
	}
}

// BasicResult can be used to store the result of queries.
// Selected fields must map the Basic fields.
type BasicResult []Basic

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (b *BasicResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Basic
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*b = append(*b, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (b *basic) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewBytes("A", b.A), nil
	case "B":
		return field.NewUint16("B", b.B), nil
	case "C":
		return field.NewFloat32("C", b.C), nil
	case "D":
		return field.NewFloat32("D", b.D), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (b *basic) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = b.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("C")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = b.Field("D")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (b *basic) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			b.A, err = field.DecodeBytes(f.Data)
		case "B":
			b.B, err = field.DecodeUint16(f.Data)
		case "C":
			b.C, err = field.DecodeFloat32(f.Data)
		case "D":
			b.D, err = field.DecodeFloat32(f.Data)
		}
		return err
	})
}

// basicTable manages the Basic table.
type basicTable struct {
	A query.BytesFieldSelector
	B query.Uint16FieldSelector
	C query.Float32FieldSelector
	D query.Float32FieldSelector
}

// newbasicTable creates a basicTable.
func newBasicTable() *basicTable {
	return &basicTable{
		A: query.BytesField("A"),
		B: query.Uint16Field("B"),
		C: query.Float32Field("C"),
		D: query.Float32Field("D"),
	}
}

// Init initializes the Basic table by ensuring the table and its index are created.
func (t *basicTable) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, t)
}

// SelectTable implements the query.TableSelector interface. It gets the Basic table from
// the transaction.
func (t *basicTable) SelectTable(tx *genji.Tx) (*genji.Table, error) {
	return tx.Table(t.TableName())
}

// Insert is a shortcut that gets the Basic table from the transaction and
// inserts a basic into it.
func (t *basicTable) Insert(tx *genji.Tx, x *basic) ([]byte, error) {
	tb, err := t.SelectTable(tx)
	if err != nil {
		return nil, err
	}

	return tb.Insert(x)
}

// TableName returns the name of the table.
func (*basicTable) TableName() string {
	return "Basic"
}

// All returns a list of all selectors for basic.
func (t *basicTable) All() []query.FieldSelector {
	return []query.FieldSelector{
		t.A,
		t.B,
		t.C,
		t.D,
	}
}

// basicResult can be used to store the result of queries.
// Selected fields must map the basic fields.
type basicResult []basic

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (b *basicResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record basic
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*b = append(*b, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (p *Pk) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", p.A), nil
	case "B":
		return field.NewInt64("B", p.B), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (p *Pk) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = p.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = p.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (p *Pk) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			p.A, err = field.DecodeString(f.Data)
		case "B":
			p.B, err = field.DecodeInt64(f.Data)
		}
		return err
	})
}

// Pk returns the primary key. It implements the table.Pker interface.
func (p *Pk) Pk() ([]byte, error) {
	return field.EncodeInt64(p.B), nil
}

// PkTable manages the Pk table.
type PkTable struct {
	A query.StringFieldSelector
	B query.Int64FieldSelector
}

// NewPkTable creates a PkTable.
func NewPkTable() *PkTable {
	return &PkTable{
		A: query.StringField("A"),
		B: query.Int64Field("B"),
	}
}

// Init initializes the Pk table by ensuring the table and its index are created.
func (t *PkTable) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, t)
}

// SelectTable implements the query.TableSelector interface. It gets the Pk table from
// the transaction.
func (t *PkTable) SelectTable(tx *genji.Tx) (*genji.Table, error) {
	return tx.Table(t.TableName())
}

// Insert is a shortcut that gets the Pk table from the transaction and
// inserts a Pk into it.
func (t *PkTable) Insert(tx *genji.Tx, x *Pk) ([]byte, error) {
	tb, err := t.SelectTable(tx)
	if err != nil {
		return nil, err
	}

	return tb.Insert(x)
}

// TableName returns the name of the table.
func (*PkTable) TableName() string {
	return "Pk"
}

// All returns a list of all selectors for Pk.
func (t *PkTable) All() []query.FieldSelector {
	return []query.FieldSelector{
		t.A,
		t.B,
	}
}

// PkResult can be used to store the result of queries.
// Selected fields must map the Pk fields.
type PkResult []Pk

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (p *PkResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Pk
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*p = append(*p, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (i *Indexed) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", i.A), nil
	case "B":
		return field.NewInt64("B", i.B), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (i *Indexed) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = i.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = i.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (i *Indexed) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			i.A, err = field.DecodeString(f.Data)
		case "B":
			i.B, err = field.DecodeInt64(f.Data)
		}
		return err
	})
}

// IndexedTable manages the Indexed table.
type IndexedTable struct {
	A query.StringFieldSelector
	B query.Int64FieldSelector
}

// NewIndexedTable creates a IndexedTable.
func NewIndexedTable() *IndexedTable {
	return &IndexedTable{
		A: query.StringField("A"),
		B: query.Int64Field("B"),
	}
}

// Init initializes the Indexed table by ensuring the table and its index are created.
func (t *IndexedTable) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, t)
}

// SelectTable implements the query.TableSelector interface. It gets the Indexed table from
// the transaction.
func (t *IndexedTable) SelectTable(tx *genji.Tx) (*genji.Table, error) {
	return tx.Table(t.TableName())
}

// Insert is a shortcut that gets the Indexed table from the transaction and
// inserts a Indexed into it.
func (t *IndexedTable) Insert(tx *genji.Tx, x *Indexed) ([]byte, error) {
	tb, err := t.SelectTable(tx)
	if err != nil {
		return nil, err
	}

	return tb.Insert(x)
}

// TableName returns the name of the table.
func (*IndexedTable) TableName() string {
	return "Indexed"
}

// Indexes returns the list of indexes of the Indexed table.
func (*IndexedTable) Indexes() []string {
	return []string{
		"A",
	}
}

// All returns a list of all selectors for Indexed.
func (t *IndexedTable) All() []query.FieldSelector {
	return []query.FieldSelector{
		t.A,
		t.B,
	}
}

// IndexedResult can be used to store the result of queries.
// Selected fields must map the Indexed fields.
type IndexedResult []Indexed

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (i *IndexedResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Indexed
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*i = append(*i, record)
		return nil
	})
}

// Field implements the field method of the record.Record interface.
func (m *MultipleTags) Field(name string) (field.Field, error) {
	switch name {
	case "A":
		return field.NewString("A", m.A), nil
	case "B":
		return field.NewInt64("B", m.B), nil
	case "C":
		return field.NewFloat32("C", m.C), nil
	case "D":
		return field.NewBool("D", m.D), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (m *MultipleTags) Iterate(fn func(field.Field) error) error {
	var err error
	var f field.Field

	f, _ = m.Field("A")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = m.Field("B")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = m.Field("C")
	err = fn(f)
	if err != nil {
		return err
	}

	f, _ = m.Field("D")
	err = fn(f)
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (m *MultipleTags) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			m.A, err = field.DecodeString(f.Data)
		case "B":
			m.B, err = field.DecodeInt64(f.Data)
		case "C":
			m.C, err = field.DecodeFloat32(f.Data)
		case "D":
			m.D, err = field.DecodeBool(f.Data)
		}
		return err
	})
}

// Pk returns the primary key. It implements the table.Pker interface.
func (m *MultipleTags) Pk() ([]byte, error) {
	return field.EncodeString(m.A), nil
}

// MultipleTagsTable manages the MultipleTags table.
type MultipleTagsTable struct {
	A query.StringFieldSelector
	B query.Int64FieldSelector
	C query.Float32FieldSelector
	D query.BoolFieldSelector
}

// NewMultipleTagsTable creates a MultipleTagsTable.
func NewMultipleTagsTable() *MultipleTagsTable {
	return &MultipleTagsTable{
		A: query.StringField("A"),
		B: query.Int64Field("B"),
		C: query.Float32Field("C"),
		D: query.BoolField("D"),
	}
}

// Init initializes the MultipleTags table by ensuring the table and its index are created.
func (t *MultipleTagsTable) Init(tx *genji.Tx) error {
	return genji.InitTable(tx, t)
}

// SelectTable implements the query.TableSelector interface. It gets the MultipleTags table from
// the transaction.
func (t *MultipleTagsTable) SelectTable(tx *genji.Tx) (*genji.Table, error) {
	return tx.Table(t.TableName())
}

// Insert is a shortcut that gets the MultipleTags table from the transaction and
// inserts a MultipleTags into it.
func (t *MultipleTagsTable) Insert(tx *genji.Tx, x *MultipleTags) ([]byte, error) {
	tb, err := t.SelectTable(tx)
	if err != nil {
		return nil, err
	}

	return tb.Insert(x)
}

// TableName returns the name of the table.
func (*MultipleTagsTable) TableName() string {
	return "MultipleTags"
}

// Indexes returns the list of indexes of the MultipleTags table.
func (*MultipleTagsTable) Indexes() []string {
	return []string{
		"D",
	}
}

// All returns a list of all selectors for MultipleTags.
func (t *MultipleTagsTable) All() []query.FieldSelector {
	return []query.FieldSelector{
		t.A,
		t.B,
		t.C,
		t.D,
	}
}

// MultipleTagsResult can be used to store the result of queries.
// Selected fields must map the MultipleTags fields.
type MultipleTagsResult []MultipleTags

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (m *MultipleTagsResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record MultipleTags
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*m = append(*m, record)
		return nil
	})
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (s *Sample) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "A":
			s.A, err = field.DecodeString(f.Data)
		case "B":
			s.B, err = field.DecodeInt64(f.Data)
		}
		return err
	})
}

// SampleResult can be used to store the result of queries.
// Selected fields must map the Sample fields.
type SampleResult []Sample

// ScanTable iterates over table.Reader and stores all the records in the slice.
func (s *SampleResult) ScanTable(tr table.Reader) error {
	return tr.Iterate(func(_ []byte, r record.Record) error {
		var record Sample
		err := record.ScanRecord(r)
		if err != nil {
			return err
		}

		*s = append(*s, record)
		return nil
	})
}

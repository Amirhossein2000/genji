package database

import (
	"bytes"
	"time"

	"github.com/asdine/genji/engine"
	"github.com/asdine/genji/index"
	"github.com/asdine/genji/record"
	"github.com/oklog/ulid"
	"github.com/pkg/errors"
)

// A Table represents a collection of records.
type Table struct {
	tx    *Tx
	store engine.Store
	name  string
}

type encodedRecordWithKey struct {
	record.EncodedRecord

	key []byte
}

func (e encodedRecordWithKey) Key() []byte {
	return e.key
}

// Iterate goes through all the records of the table and calls the given function by passing each one of them.
// If the given function returns an error, the iteration stops.
func (t Table) Iterate(fn func(r record.Record) error) error {
	// To avoid unnecessary allocations, we create the slice once and reuse it
	// at each call of the fn method.
	// Since the AscendGreaterOrEqual is never supposed to call the callback concurrently
	// we can assume that it's thread safe.
	// TODO(asdine) Add a mutex if proven necessary
	var r encodedRecordWithKey

	return t.store.AscendGreaterOrEqual(nil, func(k, v []byte) error {
		r.EncodedRecord = v
		r.key = k
		// r must be passed as pointer, not value, because passing a value to an interface
		// requires an allocation, while it doesn't for a pointer.
		return fn(&r)
	})
}

// GetRecord returns one record by key.
func (t Table) GetRecord(key []byte) (record.Record, error) {
	v, err := t.store.Get(key)
	if err != nil {
		if err == engine.ErrKeyNotFound {
			return nil, ErrRecordNotFound
		}
		return nil, errors.Wrapf(err, "failed to fetch record %q", key)
	}

	return record.EncodedRecord(v), err
}

// A PrimaryKeyer is a record that generates a key based on its primary key.
type PrimaryKeyer interface {
	PrimaryKey() ([]byte, error)
}

// Insert the record into the table.
// If the record implements the table.Pker interface, it will be used to generate a key,
// otherwise it will be generated automatically. Note that there are no ordering guarantees
// regarding the key generated by default.
func (t Table) Insert(r record.Record) ([]byte, error) {
	v, err := record.Encode(r)
	if err != nil {
		return nil, errors.Wrap(err, "failed to encode record")
	}

	var key []byte
	if pker, ok := r.(PrimaryKeyer); ok {
		key, err = pker.PrimaryKey()
		if err != nil {
			return nil, errors.Wrap(err, "failed to generate key from PrimaryKey method")
		}
		if len(key) == 0 {
			return nil, errors.New("primary key must not be empty")
		}
	} else {
		id, err := ulid.New(ulid.Timestamp(time.Now()), entropy)
		if err == nil {
			key, err = id.MarshalText()
		}
		if err != nil {
			return nil, errors.Wrap(err, "failed to generate key")
		}
	}

	_, err = t.store.Get(key)
	if err == nil {
		return nil, ErrDuplicateRecord
	}

	err = t.store.Put(key, v)
	if err != nil {
		return nil, err
	}

	indexes, err := t.Indexes()
	if err != nil {
		return nil, err
	}

	for fieldName, idx := range indexes {
		f, err := r.GetField(fieldName)
		if err != nil {
			continue
		}

		err = idx.Set(f.Data, key)
		if err != nil {
			if err == index.ErrDuplicate {
				return nil, ErrDuplicateRecord
			}

			return nil, err
		}
	}

	return key, nil
}

// Delete a record by key.
// Indexes are automatically updated.
func (t Table) Delete(key []byte) error {
	err := t.store.Delete(key)
	if err != nil {
		if err == engine.ErrKeyNotFound {
			return ErrRecordNotFound
		}
		return err
	}

	indexes, err := t.Indexes()
	if err != nil {
		return err
	}

	for _, idx := range indexes {
		err = idx.Delete(key)
		if err != nil {
			return err
		}
	}

	return nil
}

type pkWrapper struct {
	record.Record
	pk []byte
}

func (p pkWrapper) PrimaryKey() ([]byte, error) {
	return p.pk, nil
}

// Replace a record by key.
// An error is returned if the key doesn't exist.
// Indexes are automatically updated.
func (t Table) Replace(key []byte, r record.Record) error {
	err := t.Delete(key)
	if err != nil {
		if err == engine.ErrKeyNotFound {
			return ErrRecordNotFound
		}
		return err
	}

	_, err = t.Insert(pkWrapper{Record: r, pk: key})
	return err
}

// Truncate deletes all the records from the table.
func (t Table) Truncate() error {
	return t.store.Truncate()
}

// SelectTable returns the current table. Implements the query.TableSelector interface.
func (t Table) SelectTable(*Tx) (record.Iterator, error) {
	return &t, nil
}

// TableName returns the name of the table.
func (t Table) TableName() string {
	return t.name
}

// Indexes returns a map of all the indexes of a table.
func (t Table) Indexes() (map[string]index.Index, error) {
	tb, err := t.tx.GetTable(indexTable)
	if err != nil {
		return nil, err
	}

	tableName := []byte(t.name)
	indexes := make(map[string]index.Index)

	err = record.NewStream(tb).
		Filter(func(r record.Record) (bool, error) {
			f, err := r.GetField("TableName")
			if err != nil {
				return false, err
			}

			return bytes.Equal(f.Data, tableName), nil
		}).
		Iterate(func(r record.Record) error {
			f, err := r.GetField("IndexName")
			if err != nil {
				return err
			}

			indexes[string(f.Data)], err = t.tx.GetIndex(string(f.Data))
			return err
		})
	if err != nil {
		return nil, err
	}

	return indexes, nil
}
